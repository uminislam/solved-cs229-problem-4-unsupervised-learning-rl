Download Link: https://assignmentchef.com/product/solved-cs229-problem-4-unsupervised-learning-rl
<br>



<h1>1.    EM for MAP estimation</h1>

The EM algorithm that we talked about in class was for solving a maximum likelihood estimation problem in which we wished to maximize

<em>,</em>

where the <em>z</em><sup>(<em>i</em>)</sup>’s were latent random variables. Suppose we are working in a Bayesian framework, and wanted to find the MAP estimate of the parameters <em>θ </em>by maximizing

<em>.</em>

Here, <em>p</em>(<em>θ</em>) is our prior on the parameters. Generalize the EM algorithm to work for MAP estimation. You may assume that log<em>p</em>(<em>x,z</em>|<em>θ</em>) and log<em>p</em>(<em>θ</em>) are both concave in <em>θ</em>, so that the M-step is tractable if it requires only maximizing a linear combination of these quantities. (This roughly corresponds to assuming that MAP estimation is tractable when <em>x,z </em>is fully observed, just like in the frequentist case where we considered examples in which maximum likelihood estimation was easy if <em>x,z </em>was fully observed.)

Make sure your M-step is tractable, and also prove that ) (viewed as a function of <em>θ</em>) monotonically increases with each iteration of your algorithm.

<h1>2.    EM application</h1>

Consider the following problem. There are <em>P </em>papers submitted to a machine learning conference. Each of <em>R </em>reviewers reads each paper, and gives it a score indicating how good he/she thought that paper was. We let <em>x</em><sup>(<em>pr</em>) </sup>denote the score that reviewer <em>r </em>gave to paper <em>p</em>. A high score means the reviewer liked the paper, and represents a recommendation from that reviewer that it be accepted for the conference. A low score means the reviewer did not like the paper.

We imagine that each paper has some “intrinsic,” true value that we denote by <em>µ<sub>p</sub></em>, where a large value means it’s a good paper. Each reviewer is trying to estimate, based on reading the paper, what <em>µ<sub>p </sub></em>is; the score reported <em>x</em><sup>(<em>pr</em>) </sup>is then reviewer <em>r</em>’s guess of <em>µ<sub>p</sub></em>.

However, some reviewers are just generally inclined to think all papers are good and tend to give all papers high scores; other reviewers may be particularly nasty and tend to give low scores to everything. (Similarly, different reviewers may have different amounts of variance in the way they review papers, making some reviewers more consistent/reliable than others.) We let <em>ν<sub>r </sub></em>denote the “bias” of reviewer <em>r</em>. A reviewer with bias <em>ν<sub>r </sub></em>is one whose scores generally tend to be <em>ν<sub>r </sub></em>higher than they should be.

All sorts of different random factors influence the reviewing process, and hence we will use a model that incorporates several sources of noise. Specifically, we assume that reviewers’ scores are generated by a random process given as follows:

<table width="243">

 <tbody>

  <tr>

   <td width="103"><em><sub>y</sub></em>(<em>pr</em>)</td>

   <td width="24">∼</td>

   <td width="116">N(<em>µ<sub>p</sub>,σ<sub>p</sub></em><sup>2</sup>)<em>,</em></td>

  </tr>

  <tr>

   <td width="103"><em><sub>z</sub></em>(<em>pr</em>)</td>

   <td width="24">∼</td>

   <td width="116">N(<em>ν<sub>r</sub>,τ<sub>r</sub></em><sup>2</sup>)<em>,</em></td>

  </tr>

  <tr>

   <td width="103"><em>x</em>(<em>pr</em>)|<em>y</em>(<em>pr</em>)<em>,z</em>(<em>pr</em>)</td>

   <td width="24">∼</td>

   <td width="116">N(<em>y</em>(<em>pr</em>) + <em>z</em>(<em>pr</em>)<em>,σ</em>2)<em>.</em></td>

  </tr>

 </tbody>

</table>

The variables <em>y</em><sup>(<em>pr</em>) </sup>and <em>z</em><sup>(<em>pr</em>) </sup>are independent; the variables (<em>x,y,z</em>) for different paperreviewer pairs are also jointly independent. Also, we only ever observe the <em>x</em><sup>(<em>pr</em>)</sup>’s; thus, the <em>y</em><sup>(<em>pr</em>)</sup>’s and <em>z</em><sup>(<em>pr</em>)</sup>’s are all latent random variables.

We would like to estimate the parameters <em>µ<sub>p</sub>,σ<sub>p</sub></em><sup>2</sup><em>,ν<sub>r</sub>,τ<sub>r</sub></em><sup>2</sup>. If we obtain good estimates of the papers’ “intrinsic values” <em>µ<sub>p</sub></em>, these can then be used to make acceptance/rejection decisions for the conference.

We will estimate the parameters by maximizing the marginal likelihood of the data {<em>x</em><sup>(<em>pr</em>)</sup>;<em>p </em>= 1<em>,…,P,r </em>= 1<em>,…,R</em>}. This problem has latent variables <em>y</em><sup>(<em>pr</em>) </sup>and <em>z</em><sup>(<em>pr</em>)</sup>, and the maximum likelihood problem cannot be solved in closed form. So, we will use EM. Your task is to derive the EM update equations. Your final E and M step updates should consist only of addition/subtraction/multiplication/division/log/exp/sqrt of scalars; and addition/subtraction/multiplication/inverse/determinant of matrices. For simplicity, you need to treat only {<em>µ<sub>p</sub>,σ<sub>p</sub></em><sup>2</sup>;<em>p </em>= 1<em>…P</em>} and {<em>ν<sub>r</sub>,τ<sub>r</sub></em><sup>2</sup>;<em>r </em>= 1<em>…R</em>} as parameters. I.e. treat <em>σ</em><sup>2 </sup>(the conditional variance of <em>x</em><sup>(<em>pr</em>) </sup>given <em>y</em><sup>(<em>pr</em>) </sup>and <em>z</em><sup>(<em>pr</em>)</sup>) as a fixed, known constant.

<ul>

 <li>In this part, we will derive the E-step:

  <ul>

   <li>The joint distribution <em>p</em>(<em>y</em><sup>(<em>pr</em>)</sup><em>,z</em><sup>(<em>pr</em>)</sup><em>,x</em><sup>(<em>pr</em>)</sup>) has the form of a multivariate Gaussian density. Find its associated mean vector and covariance matrix in terms of the parameters <em>µ<sub>p</sub>,σ<sub>p</sub></em><sup>2</sup><em>,ν<sub>r</sub>,τ<sub>r</sub></em><sup>2</sup>, and <em>σ</em><sup>2</sup>.</li>

  </ul></li>

</ul>

[Hint: Recognize that <em>x</em><sup>(<em>pr</em>) </sup>can be written as <em>x</em><sup>(<em>pr</em>) </sup>= <em>y</em><sup>(<em>pr</em>) </sup>+ <em>z</em><sup>(<em>pr</em>) </sup>+ <em>ǫ</em><sup>(<em>pr</em>)</sup>, where <em>ǫ</em><sup>(<em>pr</em>) </sup>∼ N(0<em>,σ</em><sup>2</sup>) is independent Gaussian noise.]

<ul>

 <li>Derive an expression for <em>Q<sub>pr</sub></em>(<em>y</em><sup>(<em>pr</em>)</sup><em>,z</em><sup>(<em>pr</em>)</sup>) = <em>p</em>(<em>y</em><sup>(<em>pr</em>)</sup><em>,z</em><sup>(<em>pr</em>)</sup>|<em>x</em><sup>(<em>pr</em>)</sup>) (E-step), using the rules for conditioning on subsets of jointly Gaussian random variables (see the notes on Factor Analysis).</li>

</ul>

<ul>

 <li>Derive the M-step updates to the parameters {<em>µ<sub>p</sub>,ν<sub>r</sub>,σ<sub>p</sub></em><sup>2</sup><em>,τ<sub>r</sub></em><sup>2</sup>}. [Hint: It may help to express the lower bound on the likelihood in terms of an expectation with respect to (<em>y</em><sup>(<em>pr</em>)</sup><em>,z</em><sup>(<em>pr</em>)</sup>) drawn from a distribution with density <em>Q<sub>pr</sub></em>(<em>y</em><sup>(<em>pr</em>)</sup><em>,z</em><sup>(<em>pr</em>)</sup>).]</li>

</ul>

<strong>Remark. </strong>In a recent machine learning conference, John Platt (whose SMO algorithm you’ve seen) implemented a method quite similar to this one to estimate the papers’ true scores <em>µ<sub>p</sub></em>. (There, the problem was a bit more complicated because not all reviewers reviewed every paper, but the essential ideas are the same.) Because the model tried to estimate and correct for reviewers’ biases <em>ν<sub>r</sub></em>, its estimates of <em>µ<sub>p </sub></em>were significantly more useful for making accept/reject decisions than the reviewers’ raw scores for a paper.

<h1>3. PCA</h1>

In class, we showed that PCA finds the “variance maximizing” directions onto which to project the data. In this problem, we find another interpretation of PCA.

Suppose we are given a set of points {<em>x</em><sup>(1)</sup><em>,…,x</em><sup>(<em>m</em>)</sup>}. Let us assume that we have as usual preprocessed the data to have zero-mean and unit variance in each coordinate. For a given unit-length vector <em>u</em>, let <em>f<sub>u</sub></em>(<em>x</em>) be the projection of point <em>x </em>onto the direction given by <em>u</em>. I.e., if V = {<em>αu </em>: <em>α </em>∈ R}, then

<em>f<sub>u</sub></em>(<em>x</em>) = argmin||<em>x </em>− <em>v</em>||<sup>2</sup><em>.</em>

<em>v</em>∈V

Show that the unit-length vector <em>u </em>that minimizes the mean squared error between projected points and original points corresponds to the first principal component for the data. I.e., show that

<em>m u</em>:<em>u</em><em>T</em><em>u</em>=1 X

arg    min              k<em>x</em>(<em>i</em>) − <em>f</em><em>u</em>(<em>x</em>(<em>i</em>))k22 <em>.</em>

<em>i</em>=1

gives the first principal component.

<strong>Remark. </strong>If we are asked to find a <em>k</em>-dimensional subspace onto which to project the data so as to minimize the sum of squares distance between the original data and their projections, then we should choose the <em>k</em>-dimensional subspace spanned by the first <em>k </em>principal components of the data. This problem shows that this result holds for the case of <em>k </em>= 1.

<h1>4.    Independent components analysis</h1>

For this question you will implement the Bell and Sejnowski ICA algorithm, as covered in class. The files you’ll need for this problem are in /afs/ir/class/cs229/ps/ps4/q4. The file mix.dat contains a matrix with 5 columns, with each column corresponding to one of the mixed signals <em>x<sub>i</sub></em>. The file bellsej.m contains starter code for your implementation.

Implement and run ICA, and report what was the <em>W </em>matrix you found. Please make your code clean and very concise, and use symbol conventions as in class. To make sure your code is correct, you should listen to the resulting unmixed sources. (Some overlap in the sources may be present, but the different sources should be pretty clearly separated.)

Note: In our implementation, we <strong>annealed </strong>the learning rate <em>α </em>(slowly decreased it over time) to speed up learning. We briefly describe in bellsej.m what we did, but you should feel free to play with things to make it work best for you. In addition to using the variable learning rate to speed up convergence, one thing that we also tried was choosing a random permutation of the training data, and running stochastic gradient ascent visiting

the training data in that order (each of the specified learning rates was then used for one full pass through the data); this is something that you could try, too.

<h1>5.    Markov decision processes</h1>

Consider an MDP with finite state and action spaces, and discount factor <em>γ &lt; </em>1. Let <em>B </em>be the Bellman update operator with <em>V </em>a vector of values for each state. I.e., if <em>V </em><sup>′ </sup>= <em>B</em>(<em>V </em>), then <sup>′  </sup><em>a</em>∈<em>A </em>X<sup>′</sup>∈        <sup>′                       ′</sup>

<em>V </em>(<em>s</em>) = <em>R</em>(<em>s</em>) + <em>γ </em>max             <em>P<sub>sa</sub></em>(<em>s </em>)<em>V </em>(<em>s </em>)<em>.</em>

<em>s S</em>

<ul>

 <li><strong>[12 points] </strong>Prove that, for any two finite-valued vectors <em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, it holds true that</li>

</ul>

||<em>B</em>(<em>V</em><sub>1</sub>) − <em>B</em>(<em>V</em><sub>2</sub>)||<sub>∞ </sub>≤ <em>γ</em>||<em>V</em><sub>1 </sub>− <em>V</em><sub>2</sub>||<sub>∞</sub><em>.</em>

where ||<em>V </em>||<sub>∞ </sub>= max|<em>V </em>(<em>s</em>)|<em>.</em>

<em>s</em>∈<em>S</em>

(This shows that the Bellman update operator is a “<em>γ</em>-contraction in the max-norm.”)

<ul>

 <li><strong>[4 points] </strong>We say that <em>V </em>is a <strong>fixed point </strong>of <em>B </em>if <em>B</em>(<em>V </em>) = <em>V </em>. Using the fact that the Bellman update operator is a <em>γ</em>-contraction in the max-norm, prove that <em>B </em>has at most one fixed point—i.e., that there is at most one solution to the Bellman equations. You may assume that <em>B </em>has at least one fixed point.</li>

</ul>

<h1>6.   Reinforcement Learning: The inverted pendulum</h1>

In this problem, you will apply reinforcement learning to automatically design a policy for a difficult control task, without ever using any explicit knowledge of the dynamics of the underlying system.

The problem we will consider is the inverted pendulum or the pole-balancing problem.<a href="#_ftn1" name="_ftnref1"><sup>[1]</sup></a>

Consider the figure shown. A thin pole is connected via a free hinge to a cart, which can move laterally on a smooth table surface. The controller is said to have failed if either the angle of the pole deviates by more than a certain amount from the vertical position (i.e., if the pole falls over), or if the cart’s position goes out of bounds (i.e., if it falls off the end of the table). Our objective is to develop a controller to balance the pole with these constraints, by appropriately having the cart accelerate left and right.

We have written a simple Matlab simulator for this problem. The simulation proceeds in discrete time cycles (steps). The state of the cart and pole at any time is completely characterized by 4 parameters: the cart position <em>x</em>, the cart velocity ˙<em>x</em>, the angle of the pole <em>θ </em>measured as its deviation from the vertical position, and the angular velocity of the pole <em>θ</em>˙. Since it’d be simpler to consider reinforcement learning in a discrete state space, we have approximated the state space by a discretization that maps a state vector (<em>x,x,θ,</em>˙ <em>θ</em>˙) into a number from 1 to NUMSTATES. Your learning algorithm will need to deal only with this discretized representation of the states.

At every time step, the controller must choose one of two actions – push (accelerate) the cart right, or push the cart left. (To keep the problem simple, there is no <em>do-nothing </em>action.) These are represented as actions 1 and 2 respectively in the code. When the action choice is made, the simulator updates the state parameters according to the underlying dynamics, and provides a new discretized state.

We will assume that the reward <em>R</em>(<em>s</em>) is a function of the current state only. When the pole angle goes beyond a certain limit or when the cart goes too far out, a negative reward is given, and the system is reinitialized randomly. At all other times, the reward is zero. Your program must learn to balance the pole using only the state transitions and rewards observed.

The files for this problem are in /afs/ir/class/cs229/ps/ps4/q6. Most of the the code has already been written for you, and you need to make changes only to control.m in the places specified. This file can be run in Matlab to show a display and to plot a learning curve at the end. Read the comments at the top of the file for more details on the working of the simulation.<a href="#_ftn2" name="_ftnref2"><sup>[2]</sup></a>

(a) To solve the inverted pendulum problem, you will estimate a model (i.e., transition probabilities and rewards) for the underlying MDP, solve Bellman’s equations for this estimated MDP to obtain a value function, and act greedily with respect to this value function.

Briefly, you will maintain a current model of the MDP and a current estimate of the value function. Initially, each state has estimated reward zero, and the estimated transition probabilities are uniform (equally likely to end up in any other state).

During the simulation, you must choose actions at each time step according to some current policy. As the programgoes along taking actions, it will gather observations on transitions and rewards, which it can use to get a better estimate of the MDP model. Since it is inefficient to update the whole estimated MDP after every observation, we will store the state transitions and reward observations each time, and update the model and value function/policy only periodically. Thus, you must maintain counts of the total number of times the transition from state <em>s<sub>i </sub></em>to state <em>s<sub>j </sub></em>using action <em>a </em>has been observed (similarly for the rewards). Note that the rewards at any state are deterministic, but the state transitions are not because of the discretization of the state space (several different but close configurations may map onto the same discretized state).

Each time a failure occurs (such as if the pole falls over), you should re-estimate the transition probabilities and rewards as the average of the observed values (if any). Your program must then use value iteration to solve Bellman’s equations on the estimated MDP, to get the value function and new optimal policy for the new model.

For value iteration, use a convergence criterion that checks if the maximum absolute change in the value function on an iteration exceeds some specified tolerance.

Finally, assume that the whole learning procedure has converged once several consecutive attempts (defined by the parameter NO LEARNINGTHRESHOLD) to solve Bellman’s equation all converge in the first iteration. Intuitively, this indicates that the estimated model has stopped changing significantly.

The code outline for this problem is already in control.m, and you need to write code fragments only at the places specified in the file. There are several details (convergence criteria etc.) that are also explained inside the code. Use a discount factor of <em>γ </em>= 0<em>.</em>995.

Implement the reinforcement learning algorithm as specified, and run it. How many trials (how many times did the pole fall over or the cart fall off) did it take before the algorithm converged?

(b) Plot a learning curve showing the number of time-steps for which the pole was balanced on each trial. You just need to execute plotlearningcurve.m after control.m to get this plot.

<a href="#_ftnref1" name="_ftn1">[1]</a> The dynamics are adapted from http://www-anw.cs.umass.edu/rlr/domains.html

<a href="#_ftnref2" name="_ftn2">[2]</a> Note that the routine for drawing the cart does not work in Octave.